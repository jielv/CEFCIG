"""
input list:
1. gene table: gene_id, corresponding cell type, label (0 or 1, 0 is control, 1 is target), start, chr, end,
RNA-exp(if want to use RNA-exp as predict feature).

2. genome_size_file: homo sapiens, Mus mulus is too default

3. Training wigs table contains info of wig file (generated by danpos, fixed step wig file). file_path, feature name

4. Prediction wigs table (need to have the same number of features as training wigs
"""

"""
TO DO:
1. load data to prepare
2. perform grid optimization feature by feature
3. do the training and prediction (1. train, 2. test, generate ROC)
4. based on predict results, predict important TFs
5. output results
"""

"""
Get gene and features celltype by celltype
"""
from gene import *
from GridGo import *
from plot import *
from utils import *
from wig import Wig
from PredictGo import PredictGo
from CigNet import CigNet


if __name__ == "__main__":
    """
    1. load metadata
    """
    if False:
        metadata_path = '../ref_data/gene_metadata.txt'
        if metadata_path.endswith('.xlsx'):
            gene_meta_df = pd.read_excel(metadata_path)
        elif metadata_path.endswith('.csv'):
            gene_meta_df = pd.read_csv(metadata_path)
        elif metadata_path.endswith('.xls') or metadata_path.endswith('.txt'):
            gene_meta_df = pd.read_csv(metadata_path, sep='\t')
        else:
            gene_meta_df = None

        # columns =['hg19.kgXref.geneSymbol',	'hg19.knownGene.chrom',	'hg19.knownGene.strand', 'hg19.knownGene.txStart', 'hg19.knownGene.txEnd','hg19.knownGene.cdsStart', 'hg19.knownGene.cdsEnd', 'hg19.knownGene.exonCount', 'hg19.knownGene.exonStarts', 'hg19.knownGene.exonEnds','hg19.knownGene.name']
        gtf = pd.read_csv('../ref_data/hg19.GREATgene2UCSCknownGenes.table.xls', sep='\t')
        gtf = gtf.iloc[:, 0:5]
        gtf.columns = ['gene_id',	'chr',	'strand', 'txStart', 'txEnd']

        if len(gene_meta_df['label'].unique()) == 1:
            # only one kind of label found in gene table
            control_gtf = gtf[~gtf['gene_id'].isin(gene_meta_df['gene_id'].unique())]
            control = control_gtf.sample(gene_meta_df.shape[0])
            control_genes = list(control['gene_id'].values)
            control_df = pd.DataFrame(index=range(gene_meta_df.shape[0], 2 * gene_meta_df.shape[0]))
            control_df['gene_id'] = control_genes
            control_df['cell_type'] = list(gene_meta_df['cell_type'])
            control_df['label'] = [0] * gene_meta_df.shape[0]
            gene_meta_df = gene_meta_df.append(control_df)

        wigs_metadata_path = '../ref_data/wigs_metadata.txt'
        if wigs_metadata_path.endswith('.xlsx'):
            wigs_meta_df = pd.read_excel(wigs_metadata_path)
        elif wigs_metadata_path.endswith('.csv'):
            wigs_meta_df = pd.read_csv(wigs_metadata_path)
        elif wigs_metadata_path.endswith('.xls') or wigs_metadata_path.endswith('.txt'):
            wigs_meta_df = pd.read_csv(wigs_metadata_path, sep='\t')
        else:
            wigs_meta_df = None

        # shrink the table just for testing
        gtf = gtf.set_index(['gene_id'])

        gene_objs = []

        for i in range(gene_meta_df.shape[0]):
            gene_id, cell_type, label = gene_meta_df.iloc[i, 0], gene_meta_df.iloc[i, 1], gene_meta_df.iloc[i, 2]
            if gene_id not in gtf.index:
                print gene_id, label
                continue
            chr, start, end = gtf.ix[gene_id, 'chr'], gtf.ix[gene_id, 'txStart'], gtf.ix[gene_id, 'txEnd']
            if isinstance(chr, pd.Series):
                continue
            gene_obj = Gene(gene_id, cell_type, label, chr, start, end)
            gene_objs.append(gene_obj)

        wigs = {}
        for i in range(wigs_meta_df.shape[0]):
            cell_type, marker, wig_path = wigs_meta_df.iloc[i, 0], wigs_meta_df.iloc[i, 1], wigs_meta_df.iloc[i, 2]
            if cell_type not in wigs:
                wigs[cell_type] = {}
            wigs[cell_type][marker] = Wig(wig_path)

        for gene_obj in gene_objs:
            cell_type = gene_obj.celltype
            cur_signals = {}
            start = gene_obj.start - 10000 if gene_obj.start - 10000 > 0 else 0
            end = gene_obj.end + 10000
            chr = gene_obj.chr
            for marker in wigs[cell_type].keys():
                cur_wig_obj = wigs[cell_type][marker]
                cur_signals[marker] = cur_wig_obj.genome[chr].get_signals(start, end)
            gene_obj.add_signal(cur_signals)

        save_obj(gene_objs, '../pkl/gene_objs.pkl')

    """
    2. GridGo optimization
    """
    if False:
        gene_objs = load_obj('../pkl/gene_objs.pkl')
        # for gene_obj in gene_objs:
        #     print gene_obj.gene_id, gene_obj.chr, gene_obj.start, gene_obj.end, gene_obj.label, gene_obj.celltype
        #     print gene_obj.signal['H3K4me3']
        #     break
        gtf = pd.read_csv('../ref_data/hg19.GREATgene2UCSCknownGenes.table.xls', sep='\t')
        gtf = gtf.iloc[:, 0:5]
        gtf.columns = ['gene_id', 'chr', 'strand', 'txStart', 'txEnd']

        gridgo = GridGo(gene_objs, gtf)

        up_stream_distance_range = range(-10000, 0, 1000)
        down_stream_size_range = range(0, 10000, 1000)
        cutoff_range = range(1, 51, 5)

        gridgo.grid(up_stream_distance_range, down_stream_size_range, cutoff_range,
             up_stream_distance_grid=1000, down_stream_size_grid=1000, cutoff_grid=5,
             up_stream_distance_range_step=1000, down_stream_size_range_step=1000, cutoff_range_step=1,
             up_stream_distance_step=2, down_stream_size_step=2, cutoff_step=2,
             up_stream_distance_limit=1000, down_stream_size_limit=1000, cutoff_limit=1,
             process=20, wigs=None, fisher_c=500)
        save_obj(gridgo, '../pkl/GridGo_step1.pkl')

    if False:
        gridgo = load_obj('../pkl/GridGo_step1.pkl')

        for key in gridgo.parameters.keys():
            for body in gridgo.parameters[key].keys():
                for feature in gridgo.parameters[key][body].keys():
                    print key, body, feature, gridgo.parameters[key][body][feature][1]
        for key, value in gridgo.parameters.items():
            print key, value[1]
        # print gridgo.parameters
        gridgo.update_training_table()
        save_obj(gridgo, '../pkl/GridGo_step2.pkl')
        df = gridgo.get_training_table()

    """
    check whether ROC curve works
    """
    if False:
        metadata_path = '../ref_data/gene_metadata.txt'
        if metadata_path.endswith('.xlsx'):
            gene_meta_df = pd.read_excel(metadata_path, index_col=0)
        elif metadata_path.endswith('.csv'):
            gene_meta_df = pd.read_csv(metadata_path, index_col=0)
        elif metadata_path.endswith('.xls') or metadata_path.endswith('.txt'):
            gene_meta_df = pd.read_csv(metadata_path, sep='\t', index_col=0)
        else:
            gene_meta_df = None

        gtf = pd.read_csv('../ref_data/hg19.GREATgene2UCSCknownGenes.table.xls', sep='\t')
        gtf = gtf.iloc[:, 0:5]
        gtf.columns = ['gene_id', 'chr', 'strand', 'txStart', 'txEnd']

        gridgo = load_obj('../pkl/GridGo_step1.pkl')
        gridgo.update_training_table()
        train_df = gridgo.get_training_table()
        train_df = pd.read_csv('../ref_data/CIG_grid_training_v311_size500-_v100.csv', index_col=0)
        parameters = gridgo.parameters

        train_df.to_csv('test_training_table.xls', sep='\t')

        predictgo = PredictGo([], gtf, train_df, parameters, [], gene_meta_df)

        print [x for x in train_df.columns if x.find('label')==-1 and x.find('cell_type')==-1]

        # predictgo.prediction_roc([['H3K4me3_total_width_TSS'], ['H3K27ac_total_width_TSS'], [x for x in train_df.columns if x.find('label')==-1 and x.find('cell_type')==-1]], '/Users/boxia/PycharmProjects/CEFCIG/ROC_test',
        #                           ['H3K4me3_total_width','H3K27ac_total_width', 'Full'])

        predictgo.prediction_roc([['h3k4me3_qn_total_width'], ['h3k27ac_qn_total_width'],
                                  [x for x in train_df.columns if x.find('label') == -1 and x.find('cell_type') == -1]],
                                 '/Users/boxia/PycharmProjects/CEFCIG/ROC_test',
                                 ['H3K4me3_total_width', 'H3K27ac_total_width', 'Full'])


    """
    # important_factors = pd.read_excel('../ref_data/important_lineage_factors.xlsx', index_col=0)
        #
        # GreatGenes = pd.read_csv('../ref_data/hg19.GREATgene2UCSCknownGenes.table.xls', sep='\t',
        #                          index_col=0).index.str.upper()
        # gene_meta_df = pd.read_excel('../ref_data/CIG_Bo_curated_311.xlsx', index_col=0)
        # results = []
        # celltype = 'HUVEC'
        # # real_table = pd.read_csv('../test_data/mESC_best_parameters_CIG_v311_real_table.csv', index_col=0)
        # real_table = pd.read_csv('../test_data/HUVEC_best_parameters_CIG_v311_real_table.csv', index_col=0)
        # real_table.index = real_table.index.str.upper()
        # real_table = real_table[real_table.index.isin(GreatGenes)]
    """

    """
    3. load the real data
    """
    if False:
        gtf = pd.read_csv('../ref_data/hg19.GREATgene2UCSCknownGenes.table.xls', sep='\t')
        gtf = gtf.iloc[:, 0:5]
        gtf.columns = ['gene_id',	'chr',	'strand', 'txStart', 'txEnd']

        real_wigs_metadata_path = '../ref_data/real_wigs_metadata.txt'
        if real_wigs_metadata_path.endswith('.xlsx'):
            real_wigs_meta_df = pd.read_excel(real_wigs_metadata_path)
        elif real_wigs_metadata_path.endswith('.csv'):
            real_wigs_meta_df = pd.read_csv(real_wigs_metadata_path)
        elif real_wigs_metadata_path.endswith('.xls') or real_wigs_metadata_path.endswith('.txt'):
            real_wigs_meta_df = pd.read_csv(real_wigs_metadata_path, sep='\t')
        else:
            real_wigs_meta_df = None

        # shrink the table just for testing
        gtf = gtf.set_index(['gene_id'])

        gene_objs = []

        target_celltype = real_wigs_meta_df.iloc[:, 0].unique()[0]

        for gene_id in gtf.index:
            chr, start, end = gtf.ix[gene_id, 'chr'], gtf.ix[gene_id, 'txStart'], gtf.ix[gene_id, 'txEnd']
            if isinstance(chr, pd.Series):
                continue
            if chr == 'chrM':
                continue
            gene_obj = Gene(gene_id, target_celltype, None, chr, start, end)
            gene_objs.append(gene_obj)

        target_wigs = {}
        for i in range(real_wigs_meta_df.shape[0]):
            cell_type, marker, wig_path = real_wigs_meta_df.iloc[i, 0], real_wigs_meta_df.iloc[i, 1], real_wigs_meta_df.iloc[i, 2]
            if cell_type not in target_wigs:
                target_wigs[cell_type] = {}
            target_wigs[cell_type][marker] = Wig(wig_path)

        for gene_obj in gene_objs:
            add = True
            cell_type = gene_obj.celltype
            cur_signals = {}
            start = gene_obj.start - 10000 if gene_obj.start - 10000 > 0 else 0
            end = gene_obj.end + 10000
            chr = gene_obj.chr

            for marker in target_wigs[cell_type].keys():
                cur_wig_obj = target_wigs[cell_type][marker]
                cur_signals[marker] = cur_wig_obj.genome[chr].get_signals(start, end)
            gene_obj.add_signal(cur_signals)

        save_obj(gene_objs, '../pkl/real_gene_objs.pkl')

    if False:
        gene_objs = load_obj('../pkl/real_gene_objs.pkl')

        expression = pd.read_csv('../ref_data/genes.fpkm.qn.txt', sep='\t', index_col=0)
        expression = expression['H1-hESC_FPKM'].to_frame()
        expression.index = expression.index.str.upper()
        print expression
        expression.columns = ['RNA_exp']
        for gene_obj in gene_objs:
            if gene_obj.gene_id in expression.index:
                gene_obj.exp = expression.ix[gene_obj.gene_id, 'RNA_exp']

        gtf = pd.read_csv('../ref_data/hg19.GREATgene2UCSCknownGenes.table.xls', sep='\t')
        gtf = gtf.iloc[:, 0:5]
        gtf.columns = ['gene_id', 'chr', 'strand', 'txStart', 'txEnd']

        gridgo_obj = load_obj('../pkl/GridGo_step2.pkl')
        training_table = gridgo_obj.get_training_table()
        training_table.to_csv('training_table.csv')
        parameters = gridgo_obj.parameters

        preknown = []

        metadata_path = '../ref_data/gene_metadata.txt'
        if metadata_path.endswith('.xlsx'):
            gene_meta_df = pd.read_excel(metadata_path)
        elif metadata_path.endswith('.csv'):
            gene_meta_df = pd.read_csv(metadata_path)
        elif metadata_path.endswith('.xls') or metadata_path.endswith('.txt'):
            gene_meta_df = pd.read_csv(metadata_path, sep='\t')
        else:
            gene_meta_df = None

        predict_obj = PredictGo(gene_objs, gtf, training_table, parameters, preknown, gene_meta_df)
        real_table = predict_obj.get_real_table()
        real_table.to_csv('real_table.csv')

        save_obj(predict_obj, '../pkl/predictGo.pkl')

    if False:
        metadata_path = '../ref_data/gene_metadata.txt'
        if metadata_path.endswith('.xlsx'):
            gene_meta_df = pd.read_excel(metadata_path, index_col=0)
        elif metadata_path.endswith('.csv'):
            gene_meta_df = pd.read_csv(metadata_path, index_col=0)
        elif metadata_path.endswith('.xls') or metadata_path.endswith('.txt'):
            gene_meta_df = pd.read_csv(metadata_path, sep='\t', index_col=0)
        else:
            gene_meta_df = None

        predict_obj = load_obj('../pkl/predictGo.pkl')
        predict_obj.gene_meta_df = gene_meta_df
        predict_obj.real_table = predict_obj.real_table.fillna(0)

        predict_obj.predict()

        final_df = predict_obj.prediction
        final_df.to_csv('prediction_results.csv')



    """
    GRN prediction:
    step 1: generate CIG GRNs, generate real GRN table
    step 2:
    """
    if True:
        GRN_df_path = '../ref_data/CIG_training_network_smote6500_6300.csv'
        features = ['CIG_distance',
                    'parent_exp', 'children_exp',
                    'CIG_parent_distance', 'CIG_children_distance',
                    'RNA_exp',
                    ]
        train_df = pd.read_csv(GRN_df_path, index_col=0)
        train_df.fillna(value=0, inplace=True)
        labels = train_df.iloc[:, -1].copy()
        train_df = train_df[features].copy()
        scaler = center_normalization(train_df)
        train_df = preprocessing_table(scaler, train_df)

        predictor = predict_logisticregression(train_df, labels)

        CellNet = pd.read_csv('../ref_data/Human_Big_GRN_032014.csv', dtype={'TG': str, 'TF': str})
        CellNet.columns = ['to', 'from', 'z', 'coef', 'type', 'species']

        cignet_obj =[predictor, scaler, CellNet, features]
        save_obj(cignet_obj, '../pkl/cignet_obj.pkl')
        lala

        CIG_prediction_result = pd.read_csv('../results/H1-hESC_all_results_828.csv', index_col=0)

        expression = pd.read_csv('../ref_data/genes.fpkm.qn.txt', sep='\t', index_col=0)
        expression = expression['H1-hESC_FPKM'].to_frame()
        expression.index = expression.index.str.upper()
        print expression
        expression.columns = ['RNA_exp']

        CigNet_obj = CigNet(predictor, scaler, CellNet, features, CIG_prediction_result, expression)
        prediction_result = CigNet_obj.prediction_result
        prediction_result.to_csv('GRN_test.csv')

        # save_obj(CigNet_obj, '../pkl/CigNet_obj.pkl')

    """
    Check results GRN
    """
    if False:
        CigNet_obj = load_obj('../pkl/CigNet_obj.pkl')
        print CigNet_obj.prediction_result

    from setuptools import Extension
